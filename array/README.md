## Задание
Реализуйте контейнер `my_array`, похожий на [`std::array`](http://ru.cppreference.com/w/cpp/container/array) и
хранящий массив элементов типа `T` длины `n`, фиксированной на этапе компиляции.

Также частично специализируйте ваш шаблонный класс для `T=bool`.
В этом случае он должен занимать `N/8` байт.

### Детали реализации `my_array`
* Ограничения на параметры шаблонного класса:
  * `N > 0`.
  * Можно объявить массив типа `T`.
* Этот контейнер представляет собой обёртку над обычным массивом, в частности:
  * Все элементы расположены в памяти друг за другом *внутри* `my_array`
    (а не в динамической памяти, как в случае с `my_vector`).
  * Так как размер любого класса должен быть фиксирован на этапе компиляции,
    количество элементов в `my_array` тоже должно быть фиксировано на этапе
    компиляции. Количество элементов — это отдельный шаблонный параметр `N`.
* Заготовка интерфейса определена в предоставленном вам файле `my_array.h`.
  * Вам запрещается изменять название шаблонного класса, заголовочного файла,
    пространств имён.
  * Объявления в заготовке, скорее всего, написаны на некотором псевдокоде.
    Вам требуется сделать так, чтобы они компилировались. В частности, вам
    может потребоваться добавить `const`, возвращаемые типы, перегрузки
    имеющихся методов или ещё что-то.
  * `operator[]` и метод `at` ведут себя одинаково с единственным отличием:
    `operator[]` не проверяет переданный индекс на корректность, а `at`
    проверяет. При получении некорректного индекса `at` должен выбросить
    исключение `std::out_of_range`.
  * Метод `fill` целиком заполняет массив переданным значением. Для этого
    должен использоваться `T::operator=`.
  * Если вы используете функции/типы/константы из стандартной библиотеки,
    то в `my_array.h` должны быть подключены соответствующие заголовочные файлы
    (как и в любом уважающем себя заголовочном файле).
* Требования, которые должны выполниться автоматически, без дополнительных
  ухищрений:
  * Конструкторы и деструкторы должны вызываться ровно так же, как и в обычном
    массиве. В частности, для тривиальных типов исходное значение элементов
    может быть не определено, а для нетривиальных должно быть вызвано ровно `N`
    конструкторов.
  * Размер (`sizeof`) класса `my_array<T, N>` должен быть равен размеру массива
    из `N` элементов типа `T` (кроме случая `T=bool`).
  * Поведение всех методов должно быть максимально эффектиным и похожим на
    `std::array` (можете консультироваться с документацией).

### Специализация для `bool`
Также вам потребуется *частично специализировать* ваш шаблонный класс `my_array`
для `T=bool`. В этом случае:

* `my_array` должен занимать `N/8` байт в памяти (с округлением вверх), то есть
  вам запрещается хранить дополнительные поля.
* Разрешается (и даже потребуется) возвращать прокси-объект с перегруженными
  `operator=` и `operator bool`.
* Вам разрешается создать конструктор внутри этой специализации. Скорее всего,
  вам потребуется это сделать, чтобы избежать потенциального чтения
  неинициализированной памяти даже при нормальном использовании `my_array`.

